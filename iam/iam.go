package iam

import (
	"bytes"
	"fmt"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/go-logr/logr"
	"html/template"
)


func NewIamClient(log logr.Logger) Client {
	sess, err := session.NewSession(&aws.Config{
		Region: aws.String("eu-central-1")},
	)
	if err != nil {
		panic(err)
	}

	return iamClient{
		sess: iam.New(sess),
		log: log,
	}
}

type iamClient struct {
	sess *iam.IAM
	log  logr.Logger
}

type Client interface {
	CreateAccessKey(string) (*iam.CreateAccessKeyOutput, error)
	CreateUser(string) (string, error)
	CreateAndAttachPolicy(string, string, string) (*iam.CreatePolicyOutput, error)
	DeletePolicy(string, string) error
	DeleteUser(string) error
	DeleteAccessKey(string, string) error
}



func (a iamClient) attachPolicy(userName string, policyArn string) error {
	input := &iam.AttachUserPolicyInput{
		PolicyArn: aws.String(policyArn),
		UserName:  aws.String(userName),
	}

	result, err := a.sess.AttachUserPolicy(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case iam.ErrCodeNoSuchEntityException:
				fmt.Println(iam.ErrCodeNoSuchEntityException, aerr.Error())
			case iam.ErrCodeLimitExceededException:
				fmt.Println(iam.ErrCodeLimitExceededException, aerr.Error())
			case iam.ErrCodeInvalidInputException:
				fmt.Println(iam.ErrCodeInvalidInputException, aerr.Error())
			case iam.ErrCodePolicyNotAttachableException:
				fmt.Println(iam.ErrCodePolicyNotAttachableException, aerr.Error())
			case iam.ErrCodeServiceFailureException:
				fmt.Println(iam.ErrCodeServiceFailureException, aerr.Error())
			default:
				fmt.Println(aerr.Error())
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			fmt.Println(err.Error())
		}
		return nil
	}

	fmt.Println(result)
	return nil
}

func (a iamClient) CreateAndAttachPolicy(policyName string, userName string, bucketName string) (*iam.CreatePolicyOutput, error){

	anonBucketName := struct {
		BucketName string
	} {
		BucketName: bucketName,
	}
	policyDocument := `{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "s3:*",
            "Resource": "arn:aws:s3:::{{.BucketName}}"
        }
    ]
}`
	t, err := template.New("PolicyDocument").Parse(policyDocument)
	if err != nil {
		fmt.Println("Could not parse template")
		return nil, err
	}
	var tpl bytes.Buffer
	err = t.Execute(&tpl, anonBucketName)
	input := &iam.CreatePolicyInput{
		Description:    aws.String("Generated by S3 operator"),
		PolicyDocument: aws.String(tpl.String()),
		PolicyName:     aws.String(policyName),
	}
	result, err := a.sess.CreatePolicy(input)
	if err != nil {
		//TODO: handle error later
		return nil, err
	}
	fmt.Println("New Policy", result)

	//attach policy
	err = a.attachPolicy(userName, *result.Policy.Arn)

	if err != nil {
		return nil, err
	}

	return result, nil
}

func (a iamClient) CreateAccessKey(userName string) (*iam.CreateAccessKeyOutput,error) {
	input := &iam.CreateAccessKeyInput{
		UserName: aws.String(userName),
	}

	result, err := a.sess.CreateAccessKey(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case iam.ErrCodeNoSuchEntityException:
				fmt.Println(iam.ErrCodeNoSuchEntityException, aerr.Error())
			case iam.ErrCodeLimitExceededException:
				fmt.Println(iam.ErrCodeLimitExceededException, aerr.Error())
			case iam.ErrCodeServiceFailureException:
				fmt.Println(iam.ErrCodeServiceFailureException, aerr.Error())
			default:
				fmt.Println(aerr.Error())
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			fmt.Println(err.Error())
		}
		return nil, nil
	}

	fmt.Println(result)
	return result, nil
}

func (a iamClient) CreateUser(userName string) (string, error) {
	input := &iam.CreateUserInput{
		UserName: aws.String(userName),
	}

	result, err := a.sess.CreateUser(input)

	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case iam.ErrCodeLimitExceededException:
				fmt.Println(iam.ErrCodeLimitExceededException, aerr.Error())
			case iam.ErrCodeEntityAlreadyExistsException:
				fmt.Println(iam.ErrCodeEntityAlreadyExistsException, aerr.Error())
			case iam.ErrCodeNoSuchEntityException:
				fmt.Println(iam.ErrCodeNoSuchEntityException, aerr.Error())
			case iam.ErrCodeInvalidInputException:
				fmt.Println(iam.ErrCodeInvalidInputException, aerr.Error())
			case iam.ErrCodeConcurrentModificationException:
				fmt.Println(iam.ErrCodeConcurrentModificationException, aerr.Error())
			case iam.ErrCodeServiceFailureException:
				fmt.Println(iam.ErrCodeServiceFailureException, aerr.Error())
			default:
				fmt.Println(aerr.Error())
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			fmt.Println(err.Error())
		}
		return "", nil
	}

	return *result.User.UserName, nil
}

func (a iamClient) DeleteAccessKey(userName string, accessKeyId string) error {
	input := &iam.DeleteAccessKeyInput{
		AccessKeyId: aws.String(accessKeyId),
		UserName:    aws.String(userName),
	}

	result, err := a.sess.DeleteAccessKey(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case iam.ErrCodeNoSuchEntityException:
				a.log.Error(aerr, iam.ErrCodeNoSuchEntityException)
			case iam.ErrCodeLimitExceededException:
				a.log.Error(aerr, iam.ErrCodeLimitExceededException)
			case iam.ErrCodeServiceFailureException:
				a.log.Error(aerr, iam.ErrCodeServiceFailureException)
			default:
				a.log.Error(aerr, "AWS - Unexpected error")
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			a.log.Error(aerr, "Unexpected error")

		}
		return nil
	}

	fmt.Println(result)
	return nil
}

func (a iamClient) DeleteUser(userName string) error {
	input := &iam.DeleteUserInput{
		UserName: aws.String(userName),
	}

	_, err := a.sess.DeleteUser(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case iam.ErrCodeLimitExceededException:
				a.log.Error(aerr, iam.ErrCodeLimitExceededException)
			case iam.ErrCodeNoSuchEntityException:
				a.log.Error(aerr, iam.ErrCodeNoSuchEntityException)
			case iam.ErrCodeDeleteConflictException:
				a.log.Error(aerr, iam.ErrCodeDeleteConflictException)
			case iam.ErrCodeConcurrentModificationException:
				a.log.Error(aerr, iam.ErrCodeConcurrentModificationException)
			case iam.ErrCodeServiceFailureException:
				a.log.Error(aerr, iam.ErrCodeServiceFailureException)
			default:
				a.log.Error(aerr, "AWS: unexpected error")
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			a.log.Error(aerr, "Unexpected error")
		}
		return nil
	}
	return nil
}

func (a iamClient) DeletePolicy(policyArn string, userName string) error {


	//detach user policy
	_, err := a.sess.DetachUserPolicy(&iam.DetachUserPolicyInput{
		PolicyArn: aws.String(policyArn),
		UserName:  aws.String(userName),
	})
	if err != nil {
		a.log.Error(err, "Could not detach user policy")
		return err
	}
	//delete user policy
	_, err = a.sess.DeletePolicy(&iam.DeletePolicyInput{
		PolicyArn: aws.String(policyArn),
	})
	if err != nil {
		a.log.Error(err, "Could not delete user policy")
		return err
	}

	return nil
}
